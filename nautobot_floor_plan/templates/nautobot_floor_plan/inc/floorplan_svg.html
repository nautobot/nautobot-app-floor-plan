{% load buttons %}

{% if floor_plan %}
    <div class="pull-right noprint">
        <a href="{% url 'plugins:nautobot_floor_plan:floorplan_edit' floor_plan.pk %}" class="btn btn-warning btn-sm" id="edit-button">
            <span class="mdi mdi-checkerboard" aria-hidden="true"></span> Edit Floorplan
        </a>
        <a href="{% url 'plugins:nautobot_floor_plan:floorplantile_add' %}?floor_plan={{ floor_plan.pk }}" class="btn btn-primary btn-sm " id="add-floor-plan">
            <span class="mdi mdi-plus-box" aria-hidden="true"></span> Add Tile
        </a>
    </div>
    <h4>{{ floor_plan }}</h4>
    <div>
        Use shift+scroll wheel to zoom in or out.
        Click and drag to scroll.
        <button id="toggle-zoom-mode" class="btn btn-sm btn-default">Enable Box Zoom</button>
        <button id="reset-zoom" class="btn btn-sm btn-secondary">Reset Zoom</button><br>
        Add a tile by clicking the plus symbol on the grid OR by using the "Add Tile" button.
    </div>

    <div class="text-center text-small">
        <a href="{% url 'plugins-api:nautobot_floor_plan-api:floorplan-svg' pk=floor_plan.pk %}" class="rack_elevation_save_svg_link" download="floor_plan_{{ floor_plan.location.name }}.svg">
            <i class="mdi mdi-content-save-outline"></i> Save SVG
        </a>
    </div>

    {% comment %}
    Add Tippy.js resources
    {% endcomment %}
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/themes/light.css"/>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

    {% comment %}
    Scale the SVG by default to match the page width, preserving its aspect-ratio.
    See https://css-tricks.com/scale-svg/ for more details.
    {% endcomment %}
    <div id="floor-plan-svg-container"
         style="position: relative; height: 0; width: 100%; padding: 0; padding-bottom: calc(100% * ({{ floor_plan.y_size}} * {{ floor_plan.tile_depth }}) / ({{ floor_plan.x_size }} * {{ floor_plan.tile_width }}) / 1.2);">
        <object id="floor-plan-svg" type="image/svg+xml" role="img"
                data="{% url 'plugins-api:nautobot_floor_plan-api:floorplan-svg' pk=floor_plan.pk %}"
                style="position: absolute; height: 100%; width: 100%; left: 0; top: 0;">
        </object>
    </div>
    <style>
        .tippy-box[data-theme~='light'] .tippy-arrow {
            color: white;
        }
        .tippy-box[data-theme~='light'] {
            background-color: white;
            color: #333;
            box-shadow: 0 4px 14px -2px rgba(0, 0, 0, 0.15);
        }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svgImage = document.getElementById("floor-plan-svg");
            var isPanning = false;
            var startPoint = {x: 0, y: 0};
            var endPoint = {x: 0, y: 0};
            let zoomMode = false;
            let selectionRect = null;

            // Add toggle button event listener
            const toggleButton = document.getElementById('toggle-zoom-mode');
            if (toggleButton) {
                toggleButton.addEventListener('click', function() {
                    zoomMode = !zoomMode;
                    this.textContent = zoomMode ? 'Switch to Pan Mode' : 'Enable Box Zoom';
                    this.classList.toggle('btn-info');
                });
            }

            // Because svgImage is an '<object>', we have to wait until it loads before attaching actions to it.
            svgImage.onload = function(e) {
                const svgDisplaySize = {
                    w: svgImage.clientWidth,
                    h: svgImage.clientHeight,
                };
                const svgActualSize = {
                    w: svgImage.getSVGDocument().querySelector("svg").getAttribute("width"),
                    h: svgImage.getSVGDocument().querySelector("svg").getAttribute("height")
                };
                var viewBox = {
                    x: 0,
                    y: 0,
                    w: svgActualSize.w,
                    h: svgActualSize.h,
                };
                var scale = svgDisplaySize.w / svgActualSize.w;

                // Initialize tooltips for the SVG objects
                const svgDoc = svgImage.getSVGDocument();
                if (!svgDoc) return;

                // Helper function for consistent panning and zooming of the SVG.
                function updateViewBox(candidateViewBox) {
                    // Don't allow zooming out past the zoom that fits the entire SVG in the window.
                    var newW = Math.min(candidateViewBox.w, svgActualSize.w);
                    var newH = Math.min(candidateViewBox.h, svgActualSize.h);
                    // Don't allow panning beyond the edges of the SVG either.
                    var newViewBox = {
                        x: Math.min(Math.max(candidateViewBox.x, 0), svgActualSize.w - newW),
                        y: Math.min(Math.max(candidateViewBox.y, 0), svgActualSize.h - newH),
                        w: newW,
                        h: newH,
                    };
                    svgImage
                        .getSVGDocument()
                        .querySelector("svg")
                        .setAttribute('viewBox', `${newViewBox.x} ${newViewBox.y} ${newViewBox.w} ${newViewBox.h}`);
                    return newViewBox;
                }

                // Function to reset zoom to default view
                function resetZoom() {
                    viewBox = {
                        x: 0,
                        y: 0,
                        w: svgActualSize.w,
                        h: svgActualSize.h,
                    };
                    viewBox = updateViewBox(viewBox);
                    scale = svgDisplaySize.w / viewBox.w;
                }

                // Connect reset button to resetZoom function
                const resetButton = document.getElementById('reset-zoom');
                if (resetButton) {
                    resetButton.onclick = resetZoom;
                }

                // Create a container for our tooltip triggers that scales with the SVG
                const tooltipContainer = document.createElement('div');
                tooltipContainer.style.position = 'absolute';
                tooltipContainer.style.top = '0';
                tooltipContainer.style.left = '0';
                tooltipContainer.style.width = '100%';
                tooltipContainer.style.height = '100%';
                tooltipContainer.style.pointerEvents = 'none';
                tooltipContainer.style.transform = `scale(${scale})`;
                tooltipContainer.style.transformOrigin = 'top left';
                svgImage.parentElement.appendChild(tooltipContainer);

                // Store tooltip instances for updating during pan/zoom
                const tooltipInstances = [];

                // Function to create tooltip instance
                function createTooltip(element) {
                    // Create a trigger element
                    const trigger = document.createElement('div');
                    trigger.style.position = 'absolute';
                    trigger.style.pointerEvents = 'none';
                    tooltipContainer.appendChild(trigger);

                    const instance = tippy(trigger, {
                        content() {
                            try {
                                const data = JSON.parse(element.getAttribute('data-tooltip'));
                                return Object.entries(data)
                                    .map(([key, value]) => `<strong>${key.replace(/_/g, ' ')}:</strong> ${value}`)
                                    .join('<br>');
                            } catch (e) {
                                console.error('Error parsing tooltip data:', e);
                                return 'Error loading tooltip data';
                            }
                        },
                        allowHTML: true,
                        placement: 'top',
                        interactive: true,
                        theme: 'light',
                        arrow: true,
                        arrowType: 'round',
                        animation: 'fade',
                        offset: [0, 5],
                        trigger: 'manual',
                        appendTo: document.body,
                        popperOptions: {
                            modifiers: [{
                                name: 'preventOverflow',
                                options: {
                                    boundary: 'viewport',
                                    padding: 10
                                }
                            }]
                        }
                    });

                    // Update trigger position based on SVG element, accounting for scaling and viewBox
                    function updatePosition() {
                        const svg = svgDoc.querySelector('svg');
                        const ctm = svg.getScreenCTM();
                        const bbox = element.getBBox();
                        
                        // Get the center point of the element
                        const pt = svg.createSVGPoint();
                        pt.x = bbox.x + bbox.width/2;
                        pt.y = bbox.y;
                        
                        // Transform point to account for SVG transformations
                        const transformedPt = pt.matrixTransform(ctm);
                        const svgRect = svgImage.getBoundingClientRect();
                        
                        // Calculate position relative to the SVG viewBox
                        const viewBoxScale = {
                            x: svgRect.width / viewBox.w,
                            y: svgRect.height / viewBox.h
                        };
                        
                        const adjustedX = (transformedPt.x - viewBox.x * viewBoxScale.x) / scale;
                        const adjustedY = (transformedPt.y - viewBox.y * viewBoxScale.y) / scale;

                        trigger.style.left = `${adjustedX}px`;
                        trigger.style.top = `${adjustedY}px`;
                        trigger.style.width = `${bbox.width}px`;
                        trigger.style.height = `${bbox.height}px`;
                    }

                    // Attach mouse events to the SVG element
                    element.addEventListener('mouseenter', () => {
                        updatePosition();
                        instance.show();
                    });
                    element.addEventListener('mouseleave', () => {
                        instance.hide();
                    });

                    // Update position when viewBox changes (during pan/zoom)
                    return {
                        instance,
                        updatePosition
                    };
                }

                // Function to initialize tooltips
                function initializeTooltips() {
                    const tooltipElements = svgDoc.querySelectorAll('.object-tooltip');
                    tooltipElements.forEach(element => {
                        if (!element._tippy) {
                            tooltipInstances.push(createTooltip(element));
                        }
                    });
                }

                // Initialize tooltips after SVG is loaded
                initializeTooltips();

                // Wrap the updateViewBox function to update tooltip positions
                const originalUpdateViewBox = updateViewBox;
                updateViewBox = function(candidateViewBox) {
                    const result = originalUpdateViewBox(candidateViewBox);
                    tooltipInstances.forEach(tooltip => tooltip.updatePosition());
                    return result;
                };

                // Set up MutationObserver to watch for changes in the SVG
                const observer = new MutationObserver(initializeTooltips);
                observer.observe(svgDoc.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['class', 'data-tooltip']
                });

                // On scroll wheel in the SVG, zoom in or out
                svgImage.contentDocument.addEventListener("wheel", function(e){
                    if (!e.shiftKey) return
                    e.preventDefault();
                    var w = viewBox.w;
                    var h = viewBox.h;
                    var mx = e.offsetX;
                    var my = e.offsetY;
                    var dw = w * Math.sign(e.deltaY) * -0.05;
                    var dh = h * Math.sign(e.deltaY) * -0.05;
                    var dx = dw * mx / svgDisplaySize.w;
                    var dy = dh * my / svgDisplaySize.h;
                    var scaledViewBox = {x: viewBox.x + dx, y: viewBox.y + dy, w: viewBox.w - dw, h: viewBox.h - dh};
                    viewBox = updateViewBox(scaledViewBox);
                    scale = svgDisplaySize.w/viewBox.w;
                }, { passive: false });

                // On click in the SVG, record the click location and begin panning or box selection
                svgImage.contentDocument.onmousedown = function(e){
                    e.preventDefault();
                    
                    // Get the SVG element
                    const svg = svgDoc.querySelector("svg");
                    
                    // Create an SVG point at the mouse position
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    
                    // Convert to SVG document coordinates
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    
                    startPoint = {x: svgP.x, y: svgP.y};
                    
                    if (zoomMode) {
                        // Create selection rectangle
                        selectionRect = svgDoc.createElementNS("http://www.w3.org/2000/svg", "rect");
                        selectionRect.setAttribute("x", startPoint.x);
                        selectionRect.setAttribute("y", startPoint.y);
                        selectionRect.setAttribute("width", 0);
                        selectionRect.setAttribute("height", 0);
                        selectionRect.setAttribute("fill", "rgba(0, 123, 255, 0.2)");
                        selectionRect.setAttribute("stroke", "#007bff");
                        selectionRect.setAttribute("stroke-width", "1");
                        selectionRect.setAttribute("pointer-events", "none");
                        svg.appendChild(selectionRect);
                    } else {
                        isPanning = true;
                    }
                };

                // On dragging the mouse, update the panning location or selection rectangle
                svgImage.contentDocument.onmousemove = function(e){
                    e.preventDefault();
                    
                    // Get the SVG element
                    const svg = svgDoc.querySelector("svg");
                    
                    // Create an SVG point at the mouse position
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    
                    // Convert to SVG document coordinates
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    
                    endPoint = {x: svgP.x, y: svgP.y};
                    
                    if (zoomMode && selectionRect) {
                        // Update selection rectangle
                        const width = endPoint.x - startPoint.x;
                        const height = endPoint.y - startPoint.y;
                        
                        selectionRect.setAttribute("width", Math.abs(width));
                        selectionRect.setAttribute("height", Math.abs(height));
                        
                        if (width < 0) selectionRect.setAttribute("x", endPoint.x);
                        if (height < 0) selectionRect.setAttribute("y", endPoint.y);
                    } else if (isPanning) {
                        // For panning, we need to convert back to screen coordinates
                        const dx = (startPoint.x - endPoint.x);
                        const dy = (startPoint.y - endPoint.y);
                        
                        var movedViewBox = {
                            x: viewBox.x + dx,
                            y: viewBox.y + dy,
                            w: viewBox.w,
                            h: viewBox.h
                        };
                        
                        updateViewBox(movedViewBox);
                        
                        // Update startPoint for smoother panning
                        startPoint = endPoint;
                    }
                };

                // On releasing the mouse button, update the panning location or zoom to selection
                svgImage.contentDocument.onmouseup = function(e){
                    e.preventDefault();
                    
                    // Get the SVG element
                    const svg = svgDoc.querySelector("svg");
                    
                    // Create an SVG point at the mouse position
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    
                    // Convert to SVG document coordinates
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    
                    endPoint = {x: svgP.x, y: svgP.y};
                    
                    if (zoomMode && selectionRect) {
                        // Get the selection rectangle dimensions
                        let selWidth = Math.abs(endPoint.x - startPoint.x);
                        let selHeight = Math.abs(endPoint.y - startPoint.y);
                        
                        // Minimum selection size check
                        if (selWidth > 10 && selHeight > 10) {
                            // Get the top-left corner of the selection
                            const minX = Math.min(startPoint.x, endPoint.x);
                            const minY = Math.min(startPoint.y, endPoint.y);
                            
                            // The coordinates are already in SVG space, so we can use them directly
                            viewBox = updateViewBox({
                                x: minX,
                                y: minY,
                                w: selWidth,
                                h: selHeight
                            });
                            
                            // Update scale after zooming
                            scale = svgDisplaySize.w / viewBox.w;
                        }
                        
                        // Remove the selection rectangle
                        if (selectionRect && selectionRect.parentNode) {
                            selectionRect.parentNode.removeChild(selectionRect);
                        }
                        selectionRect = null;
                    }
                    
                    isPanning = false;
                };
                
                // Handle mouse leaving the SVG area
                svgImage.contentDocument.onmouseleave = function(e) {
                    isPanning = false;
                    if (selectionRect && selectionRect.parentNode) {
                        selectionRect.parentNode.removeChild(selectionRect);
                    }
                    selectionRect = null;
                };
            };
        });
    </script>
{% else %}
    {% comment %}
    The UI should normally not even show the option to reach this view, but someone could enter it manually.
    {% endcomment %}
    No floor plan defined. Use the "Add Floor Plan" button above to create one if desired.
{% endif %}

